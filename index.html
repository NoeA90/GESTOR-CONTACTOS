<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Recuperación • Activos vs No Activos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f141d;
      --card:#131a24;
      --border:#1c2533;
      --text:#eef3ff;
      --muted:#9aa5b7;

      --accent:#9aff5c;
      --accent-soft:#c8ff9b;

      --good:#22c55e;
      --bad:#ef4444;
      --warn:#f59e0b;

      --shadow: 0 0 20px #0006;
    }
    *{box-sizing:border-box;font-family:Inter,Roboto,Arial,sans-serif}
    body{
      margin:0;
      padding:22px;
      min-height:100vh;
      background:linear-gradient(180deg,#070a10, var(--bg));
      color:var(--text);
    }
    h1{margin:0 0 14px 0;font-size:20px;font-weight:700}
    .wrap{max-width:1400px;margin:0 auto}
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
      box-shadow:var(--shadow);
    }
    .grid{
      display:grid;
      grid-template-columns: 1.2fr 1.2fr .8fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr; }
    }
    .box{
      background:var(--panel);
      border:1px solid #1b2230;
      border-radius:12px;
      padding:14px;
      min-height:120px;
    }
    .title{
      font-size:13px;
      font-weight:800;
      color:var(--accent-soft);
      margin-bottom:10px;
    }
    input[type=file]{
      width:100%;
      padding:10px;
      background:#0d131d;
      border:1px dashed #2a3647;
      border-radius:10px;
      color:var(--muted);
      cursor:pointer;
    }
    .hint{margin-top:8px;color:var(--muted);font-size:12px;line-height:1.35}
    .btn{
      border:none;
      border-radius:10px;
      padding:12px 14px;
      font-weight:800;
      cursor:pointer;
      transition:.15s;
      display:inline-flex;
      align-items:center;
      gap:10px;
    }
    .btn:active{transform:translateY(1px)}
    .btn-main{
      width:100%;
      justify-content:center;
      background:var(--accent);
      color:#0b120a;
      font-size:15px;
      margin-top:12px;
    }
    .btn-ghost{
      background:#0d131d;
      color:var(--text);
      border:1px solid #233044;
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .options{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:8px;
      color:var(--muted);
      font-size:13px;
    }
    label.inline{display:flex;gap:8px;align-items:center}
    input[type=number]{
      width:120px;
      padding:8px;
      background:#0d131d;
      border-radius:8px;
      border:1px solid #233044;
      color:var(--text);
    }

    .statusline{
      margin-top:12px;
      background:#0d131d;
      border:1px solid #233044;
      border-radius:12px;
      padding:12px;
      color:var(--muted);
      font-size:13px;
    }
    .pills{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .pill{
      flex:1;
      min-width:200px;
      background:#0d131d;
      border:1px solid #233044;
      border-radius:12px;
      padding:12px;
    }
    .pill .k{color:var(--muted);font-size:12px}
    .pill .v{font-size:22px;font-weight:900;margin-top:4px}
    .v.good{color:var(--good)}
    .v.bad{color:var(--bad)}
    .v.accent{color:var(--accent)}
    .toolbar{
      margin-top:14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .tabs{display:flex;gap:8px;flex-wrap:wrap}
    .tab{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid #233044;
      background:#0d131d;
      color:var(--text);
      cursor:pointer;
      font-weight:800;
      font-size:13px;
    }
    .tab.active{
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(154,255,92,.12) inset;
    }
    table{
      width:100%;
      margin-top:12px;
      border-collapse:collapse;
      background:#0d131d;
      border:1px solid #233044;
      border-radius:12px;
      overflow:hidden;
    }
    th,td{
      padding:10px;
      border-bottom:1px solid #1c2533;
      font-size:13px;
      vertical-align:top;
    }
    th{
      background:#16202c;
      font-weight:900;
      color:var(--accent-soft);
      text-align:left;
      white-space:nowrap;
    }
    tr:hover td{background:#141c27}
    .badge{
      display:inline-flex;
      align-items:center;
      padding:4px 10px;
      border-radius:999px;
      font-weight:900;
      font-size:12px;
      border:1px solid;
    }
    .badge.good{color:#baffd0;border-color:#1e7a44;background:rgba(34,197,94,.12)}
    .badge.bad{color:#ffd1d1;border-color:#8c1d1d;background:rgba(239,68,68,.12)}

    .toast{
      position:fixed;
      right:18px;
      bottom:18px;
      background:#16202c;
      padding:12px 14px;
      border-radius:12px;
      opacity:0;
      transform:translateY(16px);
      pointer-events:none;
      transition:.22s;
      display:flex;
      gap:10px;
      align-items:center;
      border:1px solid #2a3647;
      box-shadow: var(--shadow);
      max-width: 420px;
    }
    .toast.show{opacity:1;transform:translateY(0);pointer-events:auto}
    .spinner{
      width:16px;height:16px;border-radius:50%;
      border:2px solid #44546a;border-top-color:var(--accent);
      animation:spin 1s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .muted{color:var(--muted)}
    .small{font-size:12px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Recuperación • Activos vs No Activos</h1>

  <div class="card">
    <div class="grid">
      <div class="box">
        <div class="title">Cargas del mes (CSV)</div>
        <input type="file" id="fileOps" accept=".csv" />
        <div class="hint">
          Este CSV es el de operaciones/cargas del período (como venías usando).<br>
          Se detecta header automáticamente (Alias/Titular/Cantidad/Fecha).
        </div>
      </div>

      <div class="box">
        <div class="title">Contactos Whaticket (CSV)</div>
        <input type="file" id="fileContacts" accept=".csv" />
        <div class="hint">
          Debe exportar columnas: <b>number,name,email,tags,metadata</b>
        </div>
      </div>

      <div class="box">
        <div class="title">Opciones</div>
        <div class="options">
          <label class="inline">
            <input type="checkbox" id="onlyNoActive" />
            Exportar SOLO NO ACTIVOS
          </label>

          <label class="inline">
            Límite filas export (0 = sin límite)
            <input type="number" id="maxRows" value="0" min="0" />
          </label>

          <label class="inline">
            Mostrar debug
            <input type="checkbox" id="debugMode" />
          </label>

          <button class="btn btn-main" id="processBtn">
            <span class="spinner" id="spin" style="display:none"></span>
            Procesar y Comparar
          </button>
        </div>
      </div>
    </div>

    <div class="toolbar">
      <button class="btn btn-ghost" id="exportPlanillaBtn">Exportar Planilla (CSV)</button>
      <div class="tabs">
        <button class="tab active" data-view="all">Vista: Todos</button>
        <button class="tab" data-view="active">Vista: Activos</button>
        <button class="tab" data-view="noactive">Vista: No Activos</button>
      </div>
      <div class="muted small" id="diag"></div>
    </div>

    <div class="statusline" id="statusBox">
      Sin procesar. Subí ambos CSV y tocá <b>Procesar y Comparar</b>.
    </div>

    <div class="pills">
      <div class="pill">
        <div class="k">Contactos totales</div>
        <div class="v accent" id="totalContacts">—</div>
      </div>
      <div class="pill">
        <div class="k">Usuarios únicos activos (cargas)</div>
        <div class="v accent" id="uniqueActiveOps">—</div>
      </div>
      <div class="pill">
        <div class="k">Detectados ACTIVO (match)</div>
        <div class="v good" id="matchedActive">—</div>
      </div>
      <div class="pill">
        <div class="k">Detectados NO ACTIVO</div>
        <div class="v bad" id="matchedNoActive">—</div>
      </div>
    </div>

    <div id="tableWrap"></div>
  </div>
</div>

<div id="toast" class="toast">
  <div class="spinner"></div>
  <div id="toastText">Procesando...</div>
</div>

<script>
/* =========================
   Helpers UI
========================= */
const toast = document.getElementById('toast');
const toastText = document.getElementById('toastText');
let toastTimer = null;
function showToast(text, duration=2200){
  if (toastTimer) { clearTimeout(toastTimer); toastTimer = null; }
  toastText.textContent = text;
  toast.classList.add('show');
  toastTimer = setTimeout(()=>{ toast.classList.remove('show'); toastTimer = null; }, duration);
}
function setSpinning(on){
  document.getElementById('spin').style.display = on ? 'inline-block' : 'none';
}

/* =========================
   Robust CSV parsing
   - auto delimiter (',' or ';')
   - supports quotes
========================= */
function detectDelimiter(text){
  // ignore sep=;
  const s = text.replace(/\uFEFF/g,'').split(/\r?\n/).slice(0, 10).join('\n');
  const comma = (s.match(/,/g)||[]).length;
  const semi  = (s.match(/;/g)||[]).length;
  return semi > comma ? ';' : ',';
}
function parseCSV(text){
  const cleaned = text.replace(/\uFEFF/g,'').replace(/\r\n/g,'\n').replace(/\r/g,'\n');
  const lines = cleaned.split('\n').filter(l => l.trim() !== '');
  const filtered = lines.filter(l => !l.toLowerCase().startsWith('sep='));
  if (!filtered.length) return { headers: [], rows: [], delimiter: ',' };

  const delimiter = detectDelimiter(filtered.join('\n'));

  const rows = [];
  let row = [];
  let field = '';
  let inQuotes = false;

  const pushField = () => { row.push(field); field = ''; };
  const pushRow = () => {
    // trim fields
    const r = row.map(v => (v ?? '').trim());
    if (r.some(v => v !== '')) rows.push(r);
    row = [];
  };

  const s = filtered.join('\n') + '\n';
  for (let i=0;i<s.length;i++){
    const ch = s[i];
    const nx = s[i+1];

    if (ch === '"'){
      if (inQuotes && nx === '"'){ field += '"'; i++; }
      else inQuotes = !inQuotes;
      continue;
    }
    if (!inQuotes && ch === delimiter){
      pushField(); continue;
    }
    if (!inQuotes && ch === '\n'){
      pushField(); pushRow(); continue;
    }
    field += ch;
  }

  const headers = (rows[0] || []).map(h => String(h||'').trim());
  const body = rows.slice(1);

  return { headers, rows: body, delimiter };
}
function lowerHeaders(headers){
  return headers.map(h => String(h||'').trim().toLowerCase());
}
function findIdx(headersLower, candidates){
  for (let i=0;i<headersLower.length;i++){
    const h = headersLower[i];
    for (const c of candidates){
      if (h === c || h.includes(c)) return i;
    }
  }
  return -1;
}

/* =========================
   Normalization / matching keys
========================= */
function stripAccents(s){
  return String(s||'')
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');
}
function normKey(s){
  // normalize usernames (alias/titular) to comparable keys
  const x = stripAccents(String(s||''))
    .toLowerCase()
    .trim();
  // keep letters/digits/underscore only
  return x.replace(/\s+/g,'').replace(/[^\p{L}\p{N}_]/gu,'');
}
function safeJSONParse(s){
  try { return JSON.parse(s); } catch { return null; }
}
function extractKeysFromMetadata(meta){
  const keys = [];
  if (!meta) return keys;

  // If JSON, traverse shallow
  const obj = safeJSONParse(meta);
  if (obj && typeof obj === 'object'){
    const candidates = ['alias','usuario','user','username','titular','player','jugador','nickname','nick'];
    for (const k of candidates){
      if (obj[k]) keys.push(normKey(obj[k]));
    }
    // also scan any string values
    for (const v of Object.values(obj)){
      if (typeof v === 'string' && v.length <= 64) keys.push(normKey(v));
    }
    return keys.filter(Boolean);
  }

  // If plain text, try patterns
  const t = String(meta);
  const patterns = [
    /alias\s*[:=]\s*([a-z0-9_\.]+)/i,
    /usuario\s*[:=]\s*([a-z0-9_\.]+)/i,
    /user(name)?\s*[:=]\s*([a-z0-9_\.]+)/i,
    /titular\s*[:=]\s*([a-z0-9_\.]+)/i,
  ];
  for (const p of patterns){
    const m = t.match(p);
    if (m){
      const val = m[m.length-1];
      keys.push(normKey(val));
    }
  }
  // fallback: if metadata is small, consider it a possible username
  if (t.length <= 40) keys.push(normKey(t));
  return keys.filter(Boolean);
}

/* =========================
   State
========================= */
let VIEW = 'all';
let RESULTS = []; // combined list
let OPS_STATS = new Map(); // key -> {opsCount, sumAmount, lastDateStr, lastDateObj}
let OPS_UNIQUE_ACTIVE = 0;
let DIAG = {};

/* =========================
   Parse OPS (cargas) CSV
   We auto-detect indices by header names when possible.
   Expected typical columns (yours): Fecha | Estado | Cantidad | Tipo | Alias | Balance ...
========================= */
function parseOpsCSV(text){
  const parsed = parseCSV(text);
  const h = parsed.headers;
  const hl = lowerHeaders(h);

  // Try detect columns
  const idxFecha = findIdx(hl, ['fecha','date','created','createdat','data']);
  const idxCantidad = findIdx(hl, ['cantidad','monto','amount','value','importe','sum']);
  const idxAlias = findIdx(hl, ['alias','usuario','user','username','jugador','player','nick']);
  const idxTitular = findIdx(hl, ['titular','nombre','name']); // optional

  // If no header, fallback based on your previous known formats:
  // mastr: fecha=0, monto=3, usuario=6 (o 5)
  // agente: fecha=0, monto=2, usuario=4 (o 3)
  let mode = 'header';
  let fallback = null;
  if (h.length < 3 || (idxFecha === -1 && idxAlias === -1)){
    // assume "agente" like
    mode = 'fallback';
    fallback = { fecha:0, monto:2, alias:4, alias2:3, titular:-1 };
  }

  const stats = new Map();

  const addUser = (userKey, monto, fechaStr, fechaObj) => {
    if (!userKey) return;
    const k = normKey(userKey);
    if (!k) return;

    const cur = stats.get(k) || { opsCount:0, sumAmount:0, lastDateStr:'', lastDateObj:null };
    cur.opsCount += 1;
    cur.sumAmount += (monto || 0);

    // last date
    const t = (fechaObj && !isNaN(fechaObj.getTime())) ? fechaObj.getTime() : NaN;
    const prevT = (cur.lastDateObj && !isNaN(cur.lastDateObj.getTime())) ? cur.lastDateObj.getTime() : NaN;
    if (!isNaN(t) && (isNaN(prevT) || t > prevT)){
      cur.lastDateObj = fechaObj;
      cur.lastDateStr = fechaStr || cur.lastDateStr;
    } else if (!cur.lastDateStr && fechaStr){
      cur.lastDateStr = fechaStr;
    }

    stats.set(k, cur);
  };

  const parseDate = (s) => {
    if (!s) return null;
    const x = String(s).trim();
    // try ISO-like
    let d = new Date(x.replace(' ', 'T'));
    if (!isNaN(d.getTime())) return d;
    d = new Date(x);
    if (!isNaN(d.getTime())) return d;
    return null;
  };
  const parseMoney = (v) => {
    const s = String(v ?? '').replace(/\s+/g,'');
    const cleaned = s.replace(/[^0-9,.\-]/g,'');
    // convert comma decimal if needed: if has ',' and no '.', treat ',' as decimal
    let x = cleaned;
    if (x.includes(',') && !x.includes('.')) x = x.replace(',', '.');
    // remove thousand separators if both exist
    if (x.includes(',') && x.includes('.')) x = x.replace(/,/g,'');
    const n = parseFloat(x);
    return isNaN(n) ? 0 : n;
  };

  let totalRows = 0;

  for (const r of parsed.rows){
    totalRows++;
    let fechaStr = '';
    let monto = 0;
    let alias = '';
    let titular = '';

    if (mode === 'fallback'){
      const f = fallback;
      fechaStr = (r[f.fecha] ?? '').trim();
      monto = parseMoney(r[f.monto]);
      alias = (r[f.alias] ?? r[f.alias2] ?? '').trim();
    } else {
      fechaStr = idxFecha !== -1 ? (r[idxFecha] ?? '').trim() : (r[0] ?? '').trim();
      monto = idxCantidad !== -1 ? parseMoney(r[idxCantidad]) : 0;
      alias = idxAlias !== -1 ? (r[idxAlias] ?? '').trim() : '';
      titular = idxTitular !== -1 ? (r[idxTitular] ?? '').trim() : '';
    }

    const fechaObj = parseDate(fechaStr);

    if (alias) addUser(alias, monto, fechaStr, fechaObj);
    if (titular) addUser(titular, monto, fechaStr, fechaObj);
  }

  return { stats, totalRows, mode, indices: { idxFecha, idxCantidad, idxAlias, idxTitular }, delimiter: parsed.delimiter, headers: parsed.headers };
}

/* =========================
   Parse Contacts CSV (Whaticket):
   number,name,email,tags,metadata
========================= */
function parseContactsCSV(text){
  const parsed = parseCSV(text);
  const h = parsed.headers;
  const hl = lowerHeaders(h);

  const idxNumber = findIdx(hl, ['number','telefono','tel','phone','cel']);
  const idxName = findIdx(hl, ['name','nombre']);
  const idxEmail = findIdx(hl, ['email','mail']);
  const idxTags = findIdx(hl, ['tags','tag']);
  const idxMeta = findIdx(hl, ['metadata','meta','dados','data']);

  // fallback by position if needed
  const get = (row, idx, fallbackIdx) => (idx !== -1 ? row[idx] : (fallbackIdx !== undefined ? row[fallbackIdx] : ''));

  const contacts = [];
  for (const r of parsed.rows){
    const number = String(get(r, idxNumber, 0) || '').trim();
    const name = String(get(r, idxName, 1) || '').trim();
    const email = String(get(r, idxEmail, 2) || '').trim();
    const tags = String(get(r, idxTags, 3) || '').trim();
    const metadata = String(get(r, idxMeta, 4) || '').trim();

    // Build matching keys
    const keys = new Set();
    if (name) keys.add(normKey(name));
    extractKeysFromMetadata(metadata).forEach(k => keys.add(k));

    contacts.push({
      number,
      name,
      email,
      tags,
      metadata,
      keys: Array.from(keys).filter(Boolean)
    });
  }

  return { contacts, totalRows: parsed.rows.length, delimiter: parsed.delimiter, headers: parsed.headers, headerOk: (idxNumber !== -1 && idxName !== -1) };
}

/* =========================
   Compare & build results
========================= */
function buildResults(contacts, opsStats){
  const out = [];
  let activeCount = 0;

  for (const c of contacts){
    let matchKey = '';
    let stat = null;

    for (const k of c.keys){
      if (opsStats.has(k)){
        matchKey = k;
        stat = opsStats.get(k);
        break;
      }
    }

    const isActive = !!stat;
    if (isActive) activeCount++;

    out.push({
      usuario: c.name || '(sin nombre)',
      telefono: c.number || '',
      estado: isActive ? 'ACTIVO' : 'NO ACTIVO',
      opsCount: stat ? stat.opsCount : 0,
      montoMes: stat ? stat.sumAmount : 0,
      ultimaFecha: stat ? (stat.lastDateStr || '') : '',
      ultimaFechaObj: stat ? stat.lastDateObj : null,
      tags: c.tags || '',
      email: c.email || '',
      metadata: c.metadata || '',
      matchKey
    });
  }

  return { out, activeCount, noActiveCount: out.length - activeCount };
}

/* =========================
   Render table
========================= */
function money(v){
  try { return '$' + Number(v||0).toLocaleString('es-AR', { maximumFractionDigits: 2 }); }
  catch { return '$' + (v||0); }
}
function escapeHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, c => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));
}
function render(){
  const statusBox = document.getElementById('statusBox');
  const tableWrap = document.getElementById('tableWrap');

  let rows = RESULTS.slice();

  if (VIEW === 'active') rows = rows.filter(r => r.estado === 'ACTIVO');
  if (VIEW === 'noactive') rows = rows.filter(r => r.estado !== 'ACTIVO');

  const maxRows = parseInt(document.getElementById('maxRows').value, 10) || 0;
  if (maxRows > 0) rows = rows.slice(0, maxRows);

  statusBox.innerHTML = `
    <b>Procesado</b><br>
    Ops: <b>${DIAG.opsTotalRows.toLocaleString()}</b> registros ·
    <b>${OPS_UNIQUE_ACTIVE.toLocaleString()}</b> usuarios únicos activos.
    Contacts: <b>${DIAG.contactsTotalRows.toLocaleString()}</b> filas.
    <div class="muted small" style="margin-top:6px">
      Matching por <b>name/metadata</b> (contacts) vs <b>alias/titular</b> (cargas), normalizado (lowercase + sin tildes + sin símbolos).
    </div>
  `;

  const html = `
    <table>
      <thead>
        <tr>
          <th>Usuario</th>
          <th>Teléfono</th>
          <th>Estado</th>
          <th>Operaciones mes</th>
          <th>Monto mes</th>
          <th>Última fecha</th>
          <th>Tags</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r => `
          <tr>
            <td>${escapeHtml(r.usuario)}</td>
            <td>${escapeHtml(r.telefono)}</td>
            <td>${r.estado === 'ACTIVO'
                ? `<span class="badge good">ACTIVO</span>`
                : `<span class="badge bad">NO ACTIVO</span>`}
            </td>
            <td>${(r.opsCount||0).toLocaleString()}</td>
            <td>${escapeHtml(money(r.montoMes||0))}</td>
            <td>${escapeHtml(r.ultimaFecha || '')}</td>
            <td>${escapeHtml(r.tags || '')}</td>
          </tr>
        `).join('')}
      </tbody>
    </table>
    <div class="muted small" style="margin-top:8px">
      Mostrando <b>${rows.length.toLocaleString()}</b> filas (${VIEW === 'all' ? 'todos' : VIEW}).
    </div>
  `;
  tableWrap.innerHTML = html;

  // Stats pills
  document.getElementById('totalContacts').textContent = (DIAG.contactsTotalRows ?? '—').toLocaleString?.() ?? '—';
  document.getElementById('uniqueActiveOps').textContent = OPS_UNIQUE_ACTIVE.toLocaleString();
  document.getElementById('matchedActive').textContent = DIAG.activeCount.toLocaleString();
  document.getElementById('matchedNoActive').textContent = DIAG.noActiveCount.toLocaleString();

  // diag debug
  const dbg = document.getElementById('debugMode').checked;
  const diag = document.getElementById('diag');
  if (!dbg){ diag.textContent = ''; return; }

  diag.textContent =
    `diag: ops_delim="${DIAG.opsDelimiter}", contacts_delim="${DIAG.contactsDelimiter}", ` +
    `ops_mode="${DIAG.opsMode}", ops_headers="${(DIAG.opsHeadersPreview||'')}", contacts_headers_ok=${DIAG.contactsHeaderOk}`;
}

/* =========================
   Export: PLANILLA formato inicial
   Header EXACTO como tu planilla_exportada_2026-01-28.csv
========================= */
function exportPlanillaCSV(){
  if (!RESULTS.length){
    showToast('Primero procesá los archivos', 1800);
    return;
  }

  const onlyNo = document.getElementById('onlyNoActive').checked;
  let rows = RESULTS.slice();
  if (onlyNo) rows = rows.filter(r => r.estado !== 'ACTIVO');

  const maxRows = parseInt(document.getElementById('maxRows').value, 10) || 0;
  if (maxRows > 0) rows = rows.slice(0, maxRows);

  // Build helper lists for side-columns (como tu export inicial)
  // - ya contactados: vacío (porque eso lo resolvés en el proceso siguiente)
  // - recuperados!: vacío
  // - actualmente cargando: lista de ACTIVOS
  // - turno mañana/tarde/noche: ACTIVOS según hora de ultimaFecha
  const activos = RESULTS.filter(r => r.estado === 'ACTIVO');

  const turno = { TM: [], TT: [], TN: [] };
  for (const r of activos){
    let h = NaN;
    if (r.ultimaFechaObj && !isNaN(r.ultimaFechaObj.getTime())) h = r.ultimaFechaObj.getHours();
    if (isNaN(h) && r.ultimaFecha){
      const m = String(r.ultimaFecha).match(/(\d{2}):(\d{2})(?::(\d{2}))?$/);
      if (m) h = parseInt(m[1], 10);
    }
    if (isNaN(h)) turno.TN.push(r.usuario);
    else if (h >= 6 && h < 14) turno.TM.push(r.usuario);
    else if (h >= 14 && h < 22) turno.TT.push(r.usuario);
    else turno.TN.push(r.usuario);
  }

  const actualmenteCargando = activos.map(r => r.usuario);

  // Header EXACTO (lo mismo que tu archivo)
  const header =
`usuarios,estado de revision,,estado actual,"VISTO, RESPONDIDO?",RECUPERADO,TURNO DE LAS CARGAS,interesado en jugar?,ya contactados,recuperados!,actualmente cargando,TURNO MAÑANA,TURNO TARDE,TURNO NOCHE,contactos a borrar\n`;

  // Mapeo de estados a planilla (como tu sistema)
  const statusToSheet = (estado) => {
    // Querés que los detectados como activos queden "ACTIVOS"
    // pero el header de tu planilla usa el lenguaje anterior:
    // EN CONTACTO / A CONTACTAR, etc.
    return (estado === 'ACTIVO') ? 'EN CONTACTO' : 'A CONTACTAR';
  };

  const csvEscape = (v) => {
    const s = String(v ?? '');
    if (s.includes('"') || s.includes(',') || s.includes('\n')) return '"' + s.replace(/"/g,'""') + '"';
    return '"' + s + '"';
  };

  // La planilla original armaba columnas laterales por listas.
  // Para mantener el mismo comportamiento: calculamos un maxLength
  // entre main list y las listas laterales.
  const maxLength = Math.max(
    rows.length,
    actualmenteCargando.length,
    turno.TM.length,
    turno.TT.length,
    turno.TN.length
  );

  let csv = header;

  for (let i=0;i<maxLength;i++){
    const main = rows[i];

    const usuario = main ? main.usuario : '';
    const estadoRev = main ? statusToSheet(main.estado) : '';
    const estadoAct = main ? statusToSheet(main.estado) : '';

    const row = [
      main ? csvEscape(usuario) : '',
      main ? csvEscape(estadoRev) : '',
      '', // columna vacía (como tu header)
      main ? csvEscape(estadoAct) : '',
      csvEscape('NO'),
      csvEscape('NO'),
      '', // TURNO DE LAS CARGAS (lo dejás para después)
      csvEscape('NO'),
      csvEscape(''), // ya contactados
      csvEscape(''), // recuperados!
      csvEscape(actualmenteCargando[i] || ''),
      csvEscape(turno.TM[i] || ''),
      csvEscape(turno.TT[i] || ''),
      csvEscape(turno.TN[i] || ''),
      csvEscape('') // contactos a borrar
    ];

    csv += row.join(',') + '\n';
  }

  downloadFile(csv, `planilla_exportada_${new Date().toISOString().slice(0,10)}.csv`, 'text/csv;charset=utf-8;');
  showToast('Planilla exportada (formato inicial)', 1600);
}

/* =========================
   Download helper
========================= */
function downloadFile(content, fileName, mimeType){
  const bom = mimeType.includes('csv') ? '\uFEFF' : '';
  const blob = new Blob([bom + content], { type: mimeType });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = fileName;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/* =========================
   Main flow
========================= */
async function readFileText(file){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = e => resolve(String(e.target.result || ''));
    fr.onerror = reject;
    fr.readAsText(file, 'utf-8');
  });
}

document.getElementById('processBtn').addEventListener('click', async () => {
  const fOps = document.getElementById('fileOps').files[0];
  const fContacts = document.getElementById('fileContacts').files[0];
  if (!fOps || !fContacts){
    showToast('Cargá ambos archivos CSV primero', 2600);
    return;
  }

  setSpinning(true);
  showToast('Procesando…', 8000);

  try{
    const [opsText, contactsText] = await Promise.all([readFileText(fOps), readFileText(fContacts)]);

    // Parse ops
    const opsParsed = parseOpsCSV(opsText);
    OPS_STATS = opsParsed.stats;
    OPS_UNIQUE_ACTIVE = OPS_STATS.size;

    // Parse contacts
    const contactsParsed = parseContactsCSV(contactsText);

    // Compare
    const built = buildResults(contactsParsed.contacts, OPS_STATS);
    RESULTS = built.out;

    DIAG = {
      opsTotalRows: opsParsed.totalRows,
      contactsTotalRows: contactsParsed.totalRows,
      activeCount: built.activeCount,
      noActiveCount: built.noActiveCount,
      opsDelimiter: opsParsed.delimiter,
      contactsDelimiter: contactsParsed.delimiter,
      opsMode: opsParsed.mode,
      opsHeadersPreview: (opsParsed.headers || []).slice(0, 8).join(' | '),
      contactsHeaderOk: contactsParsed.headerOk,
      contactsDelimiter: contactsParsed.delimiter,
      contactsHeaders: contactsParsed.headers
    };

    render();
    showToast('Listo — resultados actualizados', 1700);

  } catch (e){
    console.error(e);
    showToast('Error procesando archivos', 3200);
    alert('Error procesando archivos: ' + (e?.message || e));
  } finally {
    setSpinning(false);
  }
});

document.getElementById('exportPlanillaBtn').addEventListener('click', exportPlanillaCSV);

// Tabs
document.querySelectorAll('.tab').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    VIEW = btn.dataset.view;
    render();
  });
});
</script>
</body>
</html>
